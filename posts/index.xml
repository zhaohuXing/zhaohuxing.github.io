<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on XZH&#39;s Blog</title><link>https://zhaohuxing.github.io/posts/</link><description>Recent content in Posts on XZH&#39;s Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 20 May 2021 00:00:00 +0800</lastBuildDate><atom:link href="https://zhaohuxing.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://zhaohuxing.github.io/posts/go/</link><pubDate>Thu, 20 May 2021 00:00:00 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/go/</guid><description>Go 内存分配 内存空间包含两个重要的区域：栈和堆。Go 语言的内存分配由标准库 runtime.newobject 自动完成的。会根据分配内存大小分为两种策略，以 32KB 为界限。 对于大于 32KB 直接从堆上分配。 对于小于等于 32KB 的，Go 语言会从 mcache 本地缓存中为</description></item><item><title>MySQL 理论 - 笔记</title><link>https://zhaohuxing.github.io/posts/mysql-learn/</link><pubDate>Thu, 20 May 2021 00:00:00 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/mysql-learn/</guid><description>MySQL 事务隔离级别 ACID：原子性、一致性、隔离性、持久性 隔离级别： 读未提交 读提交 可重复读 串行化 可重复读呢，我开启了事务，还没结束，又开了事务且修改了值，但是我看到的还是我开启事务前看到的。 可重复读的实现</description></item><item><title>TCP - 笔记</title><link>https://zhaohuxing.github.io/posts/tcp/</link><pubDate>Thu, 20 May 2021 00:00:00 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/tcp/</guid><description>说一说 TCP 的三次握手？ 在 TCP 三次握手的过程中，用到了几个 TCP 首部字段：序号，确认号，确认ACK，同步SYN。 序号：TCP 是面向字节流的，在一个 TCP 连接中，传输的每个字节都是按顺序编号的。序号是指本报文段所发送</description></item><item><title>操作系统 - 笔记</title><link>https://zhaohuxing.github.io/posts/os-basic/</link><pubDate>Thu, 20 May 2021 00:00:00 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/os-basic/</guid><description>进程、线程的区别 进程就是一个运行的程序，它拥有操作系统分配给它的物理资源。 线程是进程中一个执行任务，它也是 CPU 调度执行的单元。 从拥有资源，调度，系统开销，通信方面做出比较： 进程是资源分配的基本单位，但是</description></item><item><title>Redis 核心技术 - 笔记</title><link>https://zhaohuxing.github.io/posts/redis-basic-theories/</link><pubDate>Thu, 13 May 2021 00:00:00 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/redis-basic-theories/</guid><description>基础架构 Redis 由网络框架模块、基于不同的 value 值的操作模块、索引模块、存储模块（持久化 AOF/RDB）、高可用模块（主从复制/哨兵机制）、高可扩展模块（数据分片）组成。 （此处有个图就好了。） 数据结构 Redis 基本数据</description></item><item><title>二叉树遍历</title><link>https://zhaohuxing.github.io/posts/tree_traversal/</link><pubDate>Wed, 16 Dec 2020 13:54:39 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/tree_traversal/</guid><description>二叉树（每个结点最多有两个子结点） 前序遍历：先访问根结点，再访问左子结点，最后访问右子结点 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点 后序遍历：先访问左子结点，再访问右子结点，最后访问根结</description></item><item><title>从尾到头打印链表</title><link>https://zhaohuxing.github.io/posts/reverse_print/</link><pubDate>Wed, 09 Dec 2020 13:54:39 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/reverse_print/</guid><description>问题描述 输入一个链表，按链表从尾到头的顺序返回一个 ArrayList 例如： 输入：【1，2，3，4】 输出：【4，3，2，1】 解题思路 思路一： 遍历链表，将值存到栈中，然后遍历栈中的值。 思路二： 基于思路一，递归也是一种栈结</description></item><item><title>替换空格</title><link>https://zhaohuxing.github.io/posts/replace_blank/</link><pubDate>Mon, 30 Nov 2020 13:54:39 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/replace_blank/</guid><description>问题描述 给一个字符串，将字符串中的空格替换成 %20。 例如： 输入：“We are happy.” 输出：“We%20are%20happy.” 解题思路 思路一： 申请一个新变量，遍历整个字符串，如果是空格就替换成 %20 写</description></item><item><title>二维数组中的查找</title><link>https://zhaohuxing.github.io/posts/find_target/</link><pubDate>Sat, 28 Nov 2020 18:25:46 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/find_target/</guid><description>问题描述 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 如下，如果查找数字 7</description></item><item><title>CentOS 软件管理机制</title><link>https://zhaohuxing.github.io/posts/centos-software-management-mechanism/</link><pubDate>Mon, 17 Jun 2019 13:21:55 +0800</pubDate><guid>https://zhaohuxing.github.io/posts/centos-software-management-mechanism/</guid><description>在 CentOS 上安装的软件都是以 rpm 格式的软件包进行安装的，并且每个软件包在安装时，都提供依赖检查，检查是否缺少必要的依赖。 rpm 和 yum 是 CentOS 提供的两个软件管理工具，yum 是架构在 rpm 上面发展起来的，那么简单了解下 rpm，</description></item><item><title/><link>https://zhaohuxing.github.io/posts/serverless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zhaohuxing.github.io/posts/serverless/</guid><description>到底什么是 Serverless? 分别从狭义和广义来定义：
狭义：FaaS 架构 = Trigger（事件驱动）+ FaaS（函数即服务）+ BaaS（后端即服务）= FaaS + BaaS
广义：服务端免运维 = 具备 Serverless 特性的云服务
FaaS 运行逻辑 Serverless 是对服务端运维体系的极端抽象。
具体来说，之前我们需要在服务端构建代码的运行环境，而 FaaS 应用将这一步抽象为函数服务；之前我们需要负载均衡和反向代理，而 FaaS 应用将这一步抽象为 HTTP 函数触发器；之前我们需要上传代码和启动应用，而 FaaS 应用将这一步抽象为函数代码。
FaaS 与 PaaS 最大的区别是：资源利用率，FaaS 应用实例可以缩容到 0，而 PaaS 至少为 1。
FaaS 为什么可以极速启动？ FaaS 中的冷启动是指从调用函数开始到函数实例准备完成的整个过程。冷启动，我们关注的是启动时间，基本在 100 ~ 700 毫秒。
一般会预先加载用户的实例代码，以做预热启动。
冷启动中最重要的技术：分层结构。大概可分为三层：容器，runtime，具体函数代码。
总结来说，FaaS 依赖分层调度和极速冷启动的特性，在无事件时它居然可以缩容到 0，就像我们的声控灯一样，有人的时候它可以亮起来，没人的时候，又可以自动关了。
FaaS 进程模型 从运行函数实例的进程角度看，有两种模型：
用完即毁型：函数实例准备好后，执行完函数就直接结束。（FaaS 的纯正用法） 常驻进程型：函数实例准备好后，执行完函数不结束，而是返回继续等待下一次函数被调用。这里注意，FaaS 是常驻进程型，如果一段时间没有事件触发，函数实体还是会被云服务商销毁的。 FaaS 应用如何才能快速扩缩容？ 将 FaaS 无状态话，持久化存储用 BaaS 代替。</description></item><item><title>纯编程题</title><link>https://zhaohuxing.github.io/posts/algo1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zhaohuxing.github.io/posts/algo1/</guid><description>纯编程题解题思路 举例读懂题意，梳理题目要求 列出测试用例（测试驱动开发） 总结归纳处理思想（把逻辑中重复的部分抽象出来） 第一轮编写（写注释，写清逻辑） 使用测试用例验证 练习 1.两数之和（简单） func twoSum(nums []int, target int) []int {</description></item></channel></rss>