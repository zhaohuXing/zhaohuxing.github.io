<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content=zhaohu><meta name=description content="基础架构 Redis 由网络框架模块、基于不同的 value 值的操作模块、索引模块、存储模块（持久化 AOF/RDB）、高可用模块（主从复制/哨兵机制）、高可扩展模块（数据分片）组成。 （此处有个图就好了。） 数据结构 Redis 基本数据"><meta name=keywords content=Hugo,theme,zozo><link rel=canonical href=https://zhaohuxing.github.io/posts/redis-basic-theories/><title>Redis 核心技术 - 笔记 &middot; XZH&#39;s Blog</title><link rel="shortcut icon" href=https://zhaohuxing.github.io/images/favicon.ico><link rel=stylesheet href=https://zhaohuxing.github.io/css/animate.min.css><link rel=stylesheet href=https://zhaohuxing.github.io/css/remixicon.css><link rel=stylesheet href=https://zhaohuxing.github.io/css/zozo.css><link rel=stylesheet href=https://zhaohuxing.github.io/css/highlight.css></head><body><div class="main animated"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul><li><a href=/>首页</a></li><li><a href=/posts/>归档</a></li><li><a href=/tags/>标签</a></li><li><a href=/about/>关于</a></li></ul></div><div class=menu_icon><a id=menu_icon><i class=remixicon-links-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=https://zhaohuxing.github.io><span>XZH&#39;s Blog</span></a></h1></div><div class=description><p class=sub_title>Zhaohu &amp; Software Engineer</p><div class=my_socials><a href=https://github.com/zhaohuxing title=github target=_blank><i class=remixicon-github-fill></i></a><a href=https://zhaohuxing.github.io/index.xml type=application/rss+xml title=rss target=_blank><i class=remixicon-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animated fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/redis-basic-theories/>Redis 核心技术 - 笔记</a></h2><span class=date>2021.05.13</span></div><div class="post_content markdown"><h2 id=基础架构>基础架构</h2><p>Redis 由网络框架模块、基于不同的 value 值的操作模块、索引模块、存储模块（持久化 AOF/RDB）、高可用模块（主从复制/哨兵机制）、高可扩展模块（数据分片）组成。</p><p>（此处有个图就好了。）</p><h2 id=数据结构>数据结构</h2><p>Redis 基本数据类型有：String、List、Hash、SortedSet、Set。</p><p>底层数据结构有：动态字符串、双向链表、 哈希表，跳表，压缩列表，整数数组。</p><p><img src=../../images/redis-bsds.jpg alt></p><p>为了实现从键到值的快速访问，Redis 使用一个哈希表来保存所有键值对。当写数据量大的时候，哈希冲突是不可避免的。解决哈希冲突办法：链式 Hash 和 rehash。</p><ul><li>链式哈希：在每个哈希桶下面挂一个链表</li><li>rehash：增加哈希桶数量（翻倍）</li></ul><h4 id=redis-中怎么处理哈希冲突的>Redis 中怎么处理哈希冲突的？</h4><p>为了使 rehash 操作更高效，Redis 默认使用两个全局哈希表：哈希表 1 和哈希表 2。一开始，刚插入数据时，默认使用哈希表 1，此时哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p><ol><li>给哈希表 2 分配更大的空间，例如当前哈希表 1 的两倍；</li><li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li><li>释放哈希表 1 的空间。</li></ol><p>到此，我们可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，哈希表 1 留作下次 rehash 备用。</p><p>第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 阻塞，无法服务其他请求。故 Redis 采用了渐进式 rehash。每次写的过程中会顺带着把哈希表 1 中的一个哈希桶上的 entires。没有写请求时，后台会有一个迁移线程进行迁移的。</p><h4 id=压缩表>压缩表</h4><p>压缩表实际上类似于一个数组，数组中的每一个元素，对应保存一个数据。和数组不同的是，压缩表在表头有三个字段 zlbytes, zltail, zllen, 分别表示列表长度、列表尾的偏移量和列表中 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结尾。</p><h4 id=跳表>跳表</h4><p>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据快速定位。</p><h2 id=高性能-io-模型>高性能 IO 模型</h2><p>Redis 单线程，主要是指 Redis 网络 IO 和键值对读写是由一个线程来完成，这也是 Redis 对提供键值存储服务的主要流程。但 Redis 其他的功能，比如持久化、异步删除、集群数据同步等，其实由额外的线程执行的。</p><h4 id=redis-为什么用单线程>Redis 为什么用单线程？</h4><p>多线程编程模式面临共享资源保护的问题，降低了系统代码的易调试性和可维护性。</p><h4 id=redis-单线程为什么那么快>Redis 单线程为什么那么快？</h4><ol><li>Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，如哈希表，跳表等。</li><li>Redis 采用了非阻塞 IO + IO事件通知的方式，使其在网络 IO 操作中能并发处理大量客户端请求，实现高吞吐率。</li></ol><h4 id=io-复用机制-epoll-poll-select>IO 复用机制 epoll, poll, select</h4><p>IO 复用的三种技术，select -&gt; poll -&gt; epoll。</p><p>我们先了解下，两种 IO 事件通知的方式，水平触发和边缘触发，它们常在套接字接口的文件描述符中：</p><ol><li>水平触发：应用程序可以随时检查文件描述符的状态，然后再根据状态，进行 IO 操作。</li><li>边缘触发：当文件描述符的状态发生变化改变时，发生一次通知。这时候应用程序需要尽可能多地执行 IO，直到无法继续读写，才可以停止。如果 IO 没执行完，或因为某种原因没有来得及处理，那么这次通知也就丢失了。</li></ol><p>根据水平触发的原理，select 和 poll 需要从文件描述符列表中，找出哪些可以执行 IO，然后进行真正的网络 IO 读写。最大的优点，对应用程序比较友好，它的 API 非常简单。缺点也很显而易见，应用程序使用 select 和 poll 时，需要对这些文件描述符进行轮询，请求数多的时候，比较耗时。并且 select 和 poll 还有一些其他的限制，select 使用固定长度的位相量，表示文件描述符的极客，因此会有最大描述符数量的限制，在内部检查文件描述符是用轮询的方法，处理耗时跟描述符数量是 O(N) 的关系。poll 改进了 select 的表示方法，去掉了最大描述符数量的限制，在检查文件描述符仍是轮询的方法。除此之外，应用程序每次调用 select 和 poll 时，还需要把文件描述符的集合，从用户空间传入内核空间，由内核修改后，再传出到用户空间。</p><p>epoll 很好解决了这些问题：</p><ul><li>epoll 使用红黑树，在内核中管理文件描述符的集合，这样，就不需要应用程序在每次操作时传入传出这个集合。</li><li>epoll 使用事件驱动机制，只关注有 IO 事件发生的文件描述符，不需要轮询扫描整个集合。</li></ul><h2 id=持久化>持久化</h2><p>目前，Redis 的持久化机制主要有两个机制：AOF 日志和 RDB 快照。</p><h4 id=aof-日志>AOF 日志</h4><p>Redis 先执行命令，把数据写入内存，然后把执行的命令写到日志中。有两个好处，不需要检查命令格式；不会阻塞写操作。</p><p>支持三种写回策略：</p><ol><li>同步写回</li><li>每秒写回</li><li>操作系统控制写回</li></ol><p>由于记录的是写命令，故导致 AOF 日志非常大。Redis 支持 AOF 重写机制，就是只记录最后的值。AOF 重写是由后台子进程 bgrewriteaof 来完成的，这个过程不会阻塞主线程。</p><h4 id=rdb-快照>RDB 快照</h4><p>内存快照，就是指内存中的数据在某一个时刻的状态记录。它是给全量数据做快照的。</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p><ul><li>Save：在主线程中执行，会导致阻塞。</li><li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li></ul><p>Redis 借助操作系统提供的写时复制技术，在执行快照的同时，正常处理写操作。</p><p>简单来说，bgsave 子进程是由主进程 fork 生成的，可以共享主线程的所有内存数据，bgsave 子进程运行后，开始读取主线程的内部数据，并把它们写入 RDB 文件中。</p><p>此时，如果主线程和这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是， 如果主线程要修改一块数据，那么，这个块数据就会被复制一份。然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据写入 RDB 文件。</p><p>假设每秒做一次快照，会带来两方面的开销：</p><ul><li>频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始了，容易造成恶性循环。</li><li>Bgsave 子进程需要通过 fork 操作从主线程创建出来，虽然，子进程在创建后不在阻塞线程，但是 fork 这个过程会阻塞主线程的。</li></ul><h4 id=建议>建议</h4><p>根据不同的场景选用不同的方案：</p><ul><li>数据不能丢时，内存快照和 AOF 混合使用；</li><li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li><li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li></ul><p>混合使用：简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><h2 id=数据同步>数据同步</h2><p>Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。</p><ul><li>读操作：主从库都可以。</li><li>写操作：首先到主库执行，然后主库将操作同步给从库。</li></ul><p><strong>为什么要采用读写分离的方式呢？</strong></p><p>如果不采用的话，我们需要保证数据在其他副本上的一致，就要涉及到加锁，实例间协商是否完成修改等一系列操作，但这会带来巨额的开销。</p><p><strong>主从库如何进行第一次同步？</strong></p><p><img src=https://static001.geekbang.org/resource/image/63/a1/63d18fd41efc9635e7e9105ce1c33da1.jpg alt=img></p><p>第一阶段是主从库建立连接，协商同步的过程，主要为全量复制做准备。在这一步，从库和主库建立连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p><p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。</p><ul><li>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为 ?</li><li>Offset，此时为 -1, 表示第一次复制。</li></ul><p>主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数，主库的 runID 和主库的目前复制的进度 offset，返回给从库。从库收到响应后，会记录下两个参数。</p><p>FULLRESYNC 响应表示第一次复制采用的全量复制，也是就是说，主库会把当前所有的数据都复制给从库。</p><p>第二阶段，主库将所有的数据同步给从库。从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照生成的 RDB 文件。</p><p>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库收到 RDB 文件后，会清空当前数据库，然后加载 RDB 文件。（为了避免之前数据的影响）</p><p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则 Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p><p>最后，也是第三个阶段，主库会把第二个阶段执行过程中新收到的命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作，这样一来，主从库实现同步了。</p><p>可用通过级联的模式，即一些从库跟从库连，从其他从库同步数据，以减轻主库的压力。</p><p>当主库网络断了，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令写入 repli_blacklog_buffer 这个缓冲区。</p><p>Repli_blacklog_buffer 是个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。当主从断的时候，从新连接时，PSYNC 命令会有从写的 offset。主对比自己写 offset，将中间的发给从库。</p><p>Repl_backlog_size 标记该环形缓冲区的大小，如果写速度太快，还没等同步给从库，就被覆盖掉了。</p><h2 id=哨兵>哨兵</h2><p>哨兵其实是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也运行，哨兵主要负责的就是三个任务：监控、选主、和通知。</p><p>监控：周期性地给所有的从库发送 PING 命令，检测他们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵会把它标记为下线状态；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判断主库下线，然后开始自动切换主库的流程。</p><p>选主：我们一般把哨兵选择新主库的过程称为“筛选 + 打分”，先筛选出网络连接状态差的，然后根据从库优先级（slave-priority）、从库复制进度(repl_backlog_offset)以及从库 ID 号(从小到大)。任何一轮胜出者，则结束</p><p>通知：哨兵会把新主库的连接信息发给其他从库，让他们与主库建立主从关系，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让他们把请求发到新主库上。</p><p><strong>哨兵挂了，主从库还能切换么？</strong></p><p>实际上，一旦多个实例组成了哨兵集群，即使有哨兵实例出现故障，其他哨兵还能继续协作完成主从切换的工作。</p><p>基于 pub/sub 机制，使哨兵和哨兵之间，哨兵和从库之间，哨兵和客户端之间就能建立连接了。哨兵通过投票来得到执行主从切换的权利。</p><h2 id=切片集群>切片集群</h2><p>Redis 官方提供了 Cluster 集群解决方案。Redis Cluster 采用哈希槽来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希值中。</p><p>手动分配这个 16384 个哈希槽，如果分配不完，Redis 集群将无法正常工作。</p><p>客户端保存了映射关系，可能不是最新的，导致不是对应的实例，这时实例返回 moved 重定向命令。</p><p><img src=https://static001.geekbang.org/resource/image/8f/b8/8fec8c2f76e32647d055ae6ed8cfbab8.jpg alt=img></p><h4 id=codis-的整体架构和基本流程>Codis 的整体架构和基本流程</h4><p>Codis 集群中包含了 4 类关键组件。</p><ul><li>Codis server：进行二次开发的 Redis 实例，其中增加了额外的数据结构，支持数据迁移，主要负责处理具体的数据读写操作。</li><li>Codis proxy：接收客户端的请求，并把请求转发给 codis server。</li><li>Zookeeper 集群：保存集群元数据，例如，数据位置。</li><li>Codis dashboard 和 Codis fe：共同组成了集群管理工具，codis dashboard 负责集群管理工作，包括增删 codis server，codis proxy 和数据迁移。codis fe 提供了 web 界面供管理。</li></ul><p>客户端直连 codis proxy，codis proxy 接收到请求，就会查询请求数据和 codis server 的映射关系，并把请求转发给相应的 codis server 处理。当 codis server 处理完后，会把结果返给 codis proxy。proxy 再返回给客户端。</p><p>codis 数据如何分布的，key 映射到 slot，slot 映射到 codis server。与 redis cluster 一样，区别在于，都在客户端；拆到 proxy 和 zookeeper。</p><p>Codis 迁移数据的时候，按照 slot 迁的，从源 server 每次发送 slot 里的一个数据到目标 server。目标 server 要给出确认。这时，源 server 才会删除该数据。一直重复上述操作，直到迁移完成。</p><p>Codis 支持同步迁移，同步的过程中，源 server 阻塞。异步有两个特点：</p><ul><li>当源 server 把数据发给目的 server 后，就可以处理其他请求了，不用等目的 server 写完。目的 server 写完后，传 AcK 给源 server, 源 server 再删除，整个过程数据只可读</li><li>对于 bigkey 用每一条指令进行异步迁移，从而避免将大value 序列化。</li></ul><h2 id=参考资料>参考资料</h2><p><a href=https://time.geekbang.org/column/intro/329>https://time.geekbang.org/column/intro/329</a></p><p><a href=https://time.geekbang.org/column/article/81268>https://time.geekbang.org/column/article/81268</a></p></div><div class=post_footer><div class=meta><div class=info><span class="field tags"><i class=remixicon-stack-line></i><a href=https://zhaohuxing.github.io/tags/redis/>redis</a></span></div></div></div></div></div></div><a id=back_to_top href=# class=back_to_top><span>△</span></a></div><footer class=footer><div class=powered_by><a href=https://zeuk.me></a><a href=http://www.gohugo.io/></a></div><div class=footer_slogan><span></span></div></footer><script src=https://zhaohuxing.github.io/js/jquery-3.3.1.min.js></script><script src=https://zhaohuxing.github.io/js/zozo.js></script><script src=https://zhaohuxing.github.io/js/highlight.pack.js></script><link href=https://zhaohuxing.github.io/css/fancybox.min.css rel=stylesheet><script src=https://zhaohuxing.github.io/js/fancybox.min.js></script><script>hljs.initHighlightingOnLoad()</script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\[\[','\]\]']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></body></html>